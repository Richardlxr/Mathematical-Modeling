![[时间序列.png]]
## 一、 时间序列的组成与逻辑结构

一个时间序列通常由以下四类变化形式叠加或耦合而成：

1.  **长期趋势 ($T_t$)**：指序列朝一定方向持续上升、下降或停留在某水平的倾向。
2.  **季节变动 ($S_t$)**：由于季节性因素引起的周期性波动（如羽绒服销量在冬季达到顶峰）。
3.  **循环变动 ($C_t$)**：通常指周期为一年以上，由非季节因素引起的涨落起伏（如经济周期）。
4.  **不规则变动 ($R_t$)**：由偶然因素引起的突然变动或随机波动。

### 1.1 组合模型类型
*   **加法模型**：$y_t=T_t+S_t+C_t+R_t$（适用于季节变化不随趋势变化的序列）。
*   **乘法模型**：$y_t=T_t \cdot S_t \cdot C_t \cdot R_t$（适用于季节变动幅度随长期趋势增长的序列）。
*   **混合模型**：多种模式的复合。

---

## 二、 确定性平滑预测法：移动平均

通过对邻近观测值求平均，消除随机干扰。

### 2.1 一次移动平均法 (Single Moving Average)
*   **公式**：$M_t^{(1)}=\frac{y_t+y_{t-1}+\dots+y_{t-N+1}}{N}$
*   **核心逻辑**：**修匀去噪**。通过平均，高出和低出的部分相互抵消，显现真实水平。
*   **适用场景**：**平稳序列**（无明显上升下降趋势，仅在固定水平上下波动）。
*   **例子：预测面馆客流量**
    假设某面馆最近5天客流量如下：

| 天数        | 1   | 2   | 3   | 4   | 5   |
| :-------- | :-- | :-- | :-- | :-- | :-- |
| 客流量 $y_t$ | 100 | 120 | 110 | 130 | 115 |

若取 $N=3$：
*   第5天平滑值：$M_5^{(1)}=(110+130+115)/3=118.3$。
*   **预测第6天**：直接取第5天的平滑值，即 $\hat{y}_6=118.3$。

### 2.2 二次移动平均法 (Double Moving Average)
*   **核心痛点**：当数据有明显**线性上升趋势**时，一次移动平均的预测值会永远比真实值低（**滞后性**）。
*   **公式**：$M_t^{(2)}=\frac{M_t^{(1)}+M_{t-1}^{(1)}+\dots+M_{t-N+1}^{(1)}}{N}$
*   **线性预测模型**：$\hat{y}_{t+T}=a_t+b_t T$
    *   截距：$a_t=2M_t^{(1)}-M_t^{(2)}$
    *   斜率：$b_t=\frac{2}{N-1}(M_t^{(1)}-M_t^{(2)})$
*   **例子：预测新店营业额（处于成长期）**
    数据有递增趋势：10, 20, 30, 40, 50。若取 $N=3$，一次平均 $M_5^{(1)}=40$。直接预测第6月为40显然偏低。
    **二次平均优化**：
    1. 计算一次平均：$M_3^{(1)}=20, M_4^{(1)}=30, M_5^{(1)}=40$。
    2. 计算二次平均：$M_5^{(2)}=(20+30+40)/3=30$。
    3. 参数计算：$a_5=2 \times 40-30=50, b_5=\frac{2}{3-1}(40-30)=10$。
    4. **预测第6月** ($T=1$)：$\hat{y}_6=50+10 \times 1=60$（符合每期增10的趋势）。

---

## 三、 确定性平滑预测法：指数平滑

核心逻辑：**加权平均**。离现在越近的数据权重越大，远期权重呈指数级衰减。

### 3.1 简单指数平滑 (Simple ES)
*   **公式**：$\hat{y}_{t+1} = \alpha y_t + (1 - \alpha) \hat{y}_t$
*   **适用**：不含趋势和季节性的**平稳序列**。
*   **平滑系数 $\alpha$ 的权衡**：
    *   接近 1：灵敏型，紧跟最近的实际波动。
    *   接近 0：稳健型，看重历史平均，抗干扰强。
*   **例子：面包店销量预测**
    设定 $\alpha = 0.3$，第一天实际销量100（预测也设为100）。

| 时间 (t) | 实际销量 $y_t$ | 预测销量 $\hat{y}_t$ | 计算过程 (下期预测) |
| :--- | :--- | :--- | :--- |
| 第 1 天 | 100 | 100 | $0.3 \times 100 + 0.7 \times 100 = 100$ |
| 第 2 天 | 120 | 100 | $0.3 \times 120 + 0.7 \times 100 = 106$ |
| 第 3 天 | 110 | 106 | $0.3 \times 110 + 0.7 \times 106 = 107.2$ |

### 3.2 霍特线性趋势模型 (Holt's Linear Trend)
在简单平滑基础上引入**趋势项** $b_t$。
*   **水平方程**：$l_t=\alpha x_t+(1-\alpha)(l_{t-1}+b_{t-1})$
*   **趋势方程**：$b_t=\beta(l_t-l_{t-1})+(1-\beta)b_{t-1}$
*   **预测方程**：$\hat{x}_{t+h}=l_t+hb_t$
*   **例子：新APP用户增长**
    假设 $l_{10}=1000, b_{10}=50, x_{11}=1100$，$\alpha=0.5, \beta=0.5$：
    $l_{11}=0.5 \times 1100 + 0.5 \times (1000+50) = 1075$
    $b_{11}=0.5 \times (1075-1000) + 0.5 \times 50 = 62.5$
    **预测第12天**：$1075 + 1 \times 62.5 = 1137.5$ 人。

### 3.3 阻尼趋势模型 (Damped Trend)
*   **核心逻辑**：认为增长趋势会逐渐枯竭，预测曲线在远期应逐渐趋于平缓。
*   **阻尼系数 $\phi$**：通常在 $[0.8, 0.98]$。
*   **预测方程**：$\hat{x}_{t+h} = l_t + (\phi^1 + \phi^2 + \dots + \phi^h) b_t$
*   **应用建议**：长期预测必须加阻尼，否则预测值会高得离谱。

### 3.4 霍特-温特季节性模型 (Holt-Winters)
引入第三个分量：**季节项 ($s_t$)**。
*   **加法模型**：季节波动数值稳定（每年多出100件）。
*   **乘法模型**：季节波动比例稳定（每年双11是平时的3倍）。
*   **例子：冰淇淋店销量**
    店面在扩张（趋势上升），且夏天永远是旺季（季节性）。Holt-Winters 能捕捉这种复合规律。

---

## 四、 模型推广与对比汇总

![[Screenshot 2026-01-27 at 16.22.58.png]]

| 模型名称 | 包含分量 | 预测曲线形状 |
| :--- | :--- | :--- |
| **简单指数平滑 (SES)** | 水平 | 水平直线 |
| **Holt 线性趋势模型** | 水平 + 趋势 | 有斜率的直线 |
| **Holt 阻尼趋势模型** | 水平 + 趋弱趋势 | 逐渐平缓的曲线 |
| **Holt-Winters 模型** | 水平 + 趋势 + 季节 | 带锯齿状的波动线 |

---

## 五、 随机性时间序列模型：ARIMA 家族

当确定性平滑无法满足要求时，需使用基于统计规律的 ARIMA 模型。

### 5.1 前提：平稳性 (Stationarity)（性质与观测时间无关的）
ARIMA 要求序列必须是平稳的：
1.  **均值为常数**：$E(x_t)=\mu$
2.  **方差恒定**：$Var(x_t)=\sigma^2$
3.  **协方差只与时间间隔 $s$ 有关**。

> [!important] ⭐ Key point
> 有趋势或者有季节性的时间序列是不平稳的
> 有周期的时间序列（没有趋势或者季节性）是平稳的


**不平稳怎么办？——差分方程**：
*   一阶差分：$\Delta y_t=y_t-y_{t-1}$（消除线性趋势）。
*   季节差分：$\Delta_m y_t=y_t-y_{t-m}$（消除周期性）。

### 5.2 ARIMA 模型构成与识别
*   **滞后算子 $L$**：$L^i y_t=y_{t-i}$。
*   **AR(p)**：自回归。当前值由过去 $p$ 期值决定。
*   **MA(q)**：移动平均。当前值由过去 $q$ 期预测误差决定。
*   **ARIMA(p, d, q)**：$d$ 为平稳化所需的差分次数。
*   **SARIMA**：季节性 ARIMA。

**模型定阶参考表**：

| 模型 | ACF (自相关图) | PACF (偏自相关图) |
| :--- | :--- | :--- |
| **AR(p)** | 拖尾（逐渐衰减） | **$p$ 阶截尾**（突变为0） |
| **MA(q)** | **$q$ 阶截尾** | 拖尾 |
| **ARMA(p,q)** | 拖尾 | 拖尾 |

---

## 六、 模型评估与实战准则

1.  **AIC 与 BIC 准则**：
    *   用于平衡精度与复杂度，防止过拟合。
    *   **准则**：**AIC 或 BIC 值越小越好**。
2.  **Q检验 (Ljung-Box)**：
    *   检查拟合后的**残差**是否为白噪声。如果 P 值 > 0.05，说明规律已提取干净，模型有效。
3.  **建模避坑**：
    *   **短期有效**：时间序列通常只适合中短期预测。
    *   **滞后风险**：若 $p=q=0, d=1$，模型会退化为“抄袭上一期”，预测曲线将变成一条没有任何波动信息的水平线。



### 附录：指数平滑（Holt-Winters）家族分类与实现指南

在数学建模实战中，指数平滑家族通过**水平 (Level)**、**趋势 (Trend)** 和 **季节项 (Seasonality)** 的不同组合，形成了应对各种时间序列的工具箱。

---

#### 1. 分类讨论与数学公式

下表总结了从最简单到最复杂的六种主要情形：

| 组合类型 | 对应模型 | 核心逻辑 | 预测方程（未来第 $h$ 期） |
| :--- | :--- | :--- | :--- |
| **无趋势，无季节** | **SES** (简单指数平滑) | 数据围绕固定均值波动 | $\hat{y}_{t+h}=l_t$ |
| **有趋势，无季节** | **Holt Linear** (线性趋势) | 数据持续、稳定地增长或下降 | $\hat{y}_{t+h}=l_t+hb_t$ |
| **有趋势+阻尼，无季节** | **Holt Damped** (阻尼趋势) | 增长势头随时间逐渐枯竭 | $\hat{y}_{t+h}=l_t+(\sum_{i=1}^h \phi^i)b_t$ |
| **有趋势，有季节 (加法)** | **HW Additive** | 季节波动量固定（如每月固定多100） | $\hat{y}_{t+h}=l_t+hb_t+s_{t-m+h}$ |
| **有趋势，有季节 (乘法)** | **HW Multiplicative** | 季节波动随规模等比例扩大（常用） | $\hat{y}_{t+h}=(l_t+hb_t)s_{t-m+h}$ |
| **全功能 (趋势+阻尼+季节)** | **Damped HW** | 具有周期性且总体增长趋于平缓 | $\hat{y}_{t+h}=[l_t+(\sum_{i=1}^h \phi^i)b_t]s_{t-m+h}$ |

---

#### 2. 各组件状态方程详解

##### (1) 水平项 ($l_t$)：当前基础值
所有模型均含此项。
*   简单形式：$l_t = \alpha y_t + (1-\alpha)l_{t-1}$
*   乘法季节形式：$l_t = \alpha(y_t / s_{t-m}) + (1-\alpha)(l_{t-1} + b_{t-1})$

##### (2) 趋势项 ($b_t$)：每期增量（斜率）
*   线性形式：$b_t = \beta(l_t - l_{t-1}) + (1-\beta)b_{t-1}$
*   阻尼形式：$b_t = \beta(l_t - l_{t-1}) + (1-\beta)\phi b_{t-1}$

##### (3) 季节项 ($s_t$)：周期性因子
*   加法因子（$m$ 为周期）：$s_t = \gamma(y_t - l_t) + (1-\gamma)s_{t-m}$
*   乘法因子：$s_t = \gamma(y_t / l_t) + (1-\gamma)s_{t-m}$

---

#### 3. 例子辅助理解

*   **场景 A (SES)**：预测某水库每天的静止水位。没有涨跌趋势，只需参考最近几天的平均水平。
*   **场景 B (Holt Linear)**：预测一个初创公司新注册用户数。用户数正以每天约 500 人的速度稳步增长。
*   **场景 C (Holt Damped)**：预测某款流行手游的生命周期。前期爆发式增长，但你知道几个月后由于市场饱和，增长会变慢并最终停滞。
*   **场景 D (Holt-Winters Multiplicative)**：预测航空公司每月的乘客量。乘客量逐年上升（趋势），且每年春节和暑假必定是高峰，高峰期的乘客量是年平均值的 1.5 倍（乘法季节性）。

---

#### 4. Python 编程实现笔记

在 Python 中使用 `statsmodels` 库的 `ExponentialSmoothing` 类可以一站式解决。

##### 4.1 核心函数参数配置
```python
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# 定义模型的基本格式
model = ExponentialSmoothing(
    data, 
    trend='add',          # 趋势：'add' 为线性, None 为无趋势
    damped_trend=True,    # 阻尼：True 开启, False 关闭
    seasonal='mul',       # 季节：'mul' 乘法, 'add' 加法, None 无季节
    seasonal_periods=12   # 季节周期：月度12, 季度4
)
```

##### 4.2 查阅即用的完整代码模板
```python
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# 1. 准备数据 (示例：包含趋势和季节性的月度数据)
data = [100, 110, 130, 150, 120, 110, 100, 90, 110, 140, 170, 180,
        120, 135, 155, 180, 145, 130, 120, 110, 130, 160, 195, 210]
series = pd.Series(data)

# 2. 拟合模型 (自动估算 alpha, beta, gamma, phi)
# initialization_method="estimated" 推荐用于数据量较少时
fit_model = ExponentialSmoothing(
    series, trend='add', seasonal='mul', seasonal_periods=12, damped_trend=True
).fit()

# 3. 预测未来 6 期
forecast = fit_model.forecast(6)

# 4. 评估指标查看 (AIC/BIC 越小说明模型越简洁准确)
print(f"AIC: {fit_model.aic}")
print(f"拟合参数: {fit_model.params}")

# 5. 可视化
series.plot(label='Actual')
fit_model.fittedvalues.plot(label='Fitted', linestyle='--')
forecast.plot(label='Forecast', color='red')
plt.legend()
plt.show()
```

##### 4.3 避坑准则
1.  **数据非负性**：如果选择**乘法季节模型** (`seasonal='mul'`)，原始数据中严禁出现 **0 或负数**，否则计算会报错。
2.  **数据长度**：拟合季节性模型至少需要 **2 个完整周期** 的数据（如月度数据最少 24 个点）。
3.  **阻尼建议**：在进行 **24 期以上** 的长期预测时，建议始终开启 `damped_trend=True` 以防止预测值失真。




### 附录：ARIMA模型操作流程

### 一、 第一阶段：诊断——平稳性评估
**你的需求**：我想知道这组数据能不能直接拿来建立 ARIMA 模型。

#### 1. 逻辑理解
*   **平稳性**：指数据的统计特性（均值、方差）不随时间改变。
*   **通俗标准**：数据围绕一个常数上下随机波动，没有明显的趋势（往上涨或往下跌），也没有越来越大的波动。

#### 2. 操作方法
*   **看图（直观但主观）**：看时序图。如果是斜着的，不平稳；如果是波浪形，不平稳。
*   **看 ACF/PACF（稍微专业）**：如果自相关系数（ACF）掉得非常慢，说明不平稳。
*   **ADF 检验（应试必写，最权威）**：这是一个假设检验。
    *   **P-value < 0.05**：数据平稳（健康），可以建模。
    *   **P-value > 0.05**：数据不平稳（有病），需要处理。

#### 3. 编程实现
*   **Python (`statsmodels`)**:
    ```python
    from statsmodels.tsa.stattools import adfuller
    res = adfuller(data)
    print(f"P-value: {res[1]}") # 重点看这个
    ```
*   **Matlab**:
    ```matlab
    [h, pValue] = adftest(data); % h=1 表示平稳
    ```

---

### 二、 第二阶段：治疗——差分操作
**你的需求**：我的数据不平稳（有趋势），我得把它变平稳。

#### 1. 逻辑理解
*   **差分（Differencing）**：就是用“今天的值 - 昨天的值”。
*   **意义**：如果你每天长高 1 厘米（趋势不平稳），那么“今天身高 - 昨天身高”永远等于 1（数据变成了平稳的常数 1）。
*   **阶数 $d$**：做一次减法叫一阶差分，做两次叫二阶差分。比赛中 $d$ 通常取 1 或 2，再多就失真了。

#### 2. 编程实现
*   **Python**: `data.diff().dropna()`
*   **Matlab**: `diff(data)`

---

### 三、 第三阶段：定阶与建模——ARIMA($p,d,q$)
**你的需求**：我已经把数据变平稳了，现在要确定模型参数并预测。

#### 1. 逻辑理解
ARIMA 由三部分组成：
*   **$p$ (AR, 自回归)**：当前的数值和过去几期数值的关系。
*   **$d$ (Integrated, 差分)**：你刚才做了几次差分，这里 $d$ 就填几。
*   **$q$ (MA, 移动平均)**：当前的数值和过去几期预测误差的关系。

#### 2. 操作方法（应试捷径）
PPT 里讲了看 ACF/PACF 图的“截尾”来定阶，这在比赛中太难操作。
**实战准则：AIC/BIC 最小化（网格搜索）。**
让计算机把 $p$ 和 $q$ 从 0 到 4 全部试一遍，哪个模型的 AIC（赤池信息准则）分数值最低，就选哪个。AIC 越小，说明模型用最少的参数实现了最好的拟合。

#### 3. 编程实现（推荐 Python，因为有自动定阶神器）
*   **Python (推荐使用 `pmdarima` 库)**：
    ```python
    import pmdarima as pm
    # 自动搜索最优的 p, d, q
    model = pm.auto_arima(data, seasonal=False) 
    print(model.summary()) # 直接出结果
    ```

---

### 四、 第四阶段：体检——残差检验
**你的需求**：模型建好了，我要证明这个模型是可靠的，没漏掉信息。

#### 1. 逻辑理解
*   如果模型很棒，那么“实际值 - 预测值”剩下的**残差**应该是**白噪声**（完全的随机乱码，没有任何规律）。
*   **Q检验（Ljung-Box 检验）**：
    *   **P-value > 0.05**：残差是白噪声（体检合格），模型可用。
    *   **P-value < 0.05**：残差里还有规律没挖出来（体检不合格），得重新定阶。

#### 2. 编程实现
*   **Python**:
    ```python
    from statsmodels.stats.diagnostic import acorr_ljungbox
    # 这里的 residuals 是你模型的残差
    res = acorr_ljungbox(model.resid(), lags=[10])
    print(res) # 看 lb_pvalue
    ```

---

### 五、 实用操作总结表（查阅即用）

| 我的需求             | 需要的操作         | 核心指标 / 公式                      | 结论判定               |
| :--------------- | :------------ | :----------------------------- | :----------------- |
| **判断数据能不能建模**    | ADF 检验        | $P$-value                      | $<0.05$ 则开始建模      |
| **数据有增长趋势**      | 一阶差分          | $\Delta y_t = y_t - y_{t-1}$   | 消除线性增长             |
| **数据有固定周期波动**    | 季节差分          | $\Delta_m y_t = y_t - y_{t-m}$ | 消除季节性              |
| **确定 $p, q$ 参数** | 网格搜索          | AIC / BIC                      | 越小模型越优             |
| **检查模型行不行**      | Q 检验          | $P$-value                      | $>0.05$ 说明模型抓取规律充分 |
| **最后出结果**        | 预测 (Forecast) | $\hat{y}_{t+h}$                | 给出未来 $h$ 期的预测值     |
###  全流程实战示例：预测某工厂的用电量

题目给了你某工厂**过去 24 个月的月度用电量数据**，要求你预测**未来 3 个月**的用电量。

#### **第一步：画图观察（视觉诊断）**
*   **操作**：把这 24 个点连成线。
*   **发现**：你发现电量曲线整体是往斜上方走的（有趋势），而且每年夏天都会出现一个尖峰（有周期）。
*   **需求**：这种斜着的数据不能直接喂给模型，模型会“消化不良”。

#### **第二步：平稳性体检（ADF检验）**
*   **操作**：运行 Python 代码进行 **ADF Test**。
*   **结论**：得到 $P$-value = 0.85。因为 $0.85 > 0.05$，说明数据**不平稳**，必须进行“治疗”。

#### **第三步：治疗数据（差分操作）**
*   **操作**：进行**一阶差分**（用本月电量减去上月电量）。
*   **结论**：再做一次 ADF 检验，发现 $P$-value = 0.01。此时 $0.01 < 0.05$，体检通过！数据变“平”了。
*   **参数记录**：因为做了一次差分，所以 ARIMA 的参数 **$d=1$**。

#### **第四步：寻找最优配方（AIC/BIC 定阶）**
*   **操作**：让计算机运行网格搜索（尝试不同的 $p, q$ 组合）。
*   **对比结果**：
    *   ARIMA(1, 1, 1) 的 AIC = 450
    *   ARIMA(2, 1, 1) 的 AIC = 420 (选这个，越小越好)
*   **确定参数**：最终确定模型为 **ARIMA(2, 1, 1)**。

#### **第五步：检查模型是否“提取干净”（残差检验）**
*   **操作**：计算实际用电量和模型拟合值之间的差（残差），做 **Ljung-Box 检验**。
*   **结论**：得到 $P$-value = 0.60。因为 $0.60 > 0.05$，说明残差是纯粹的胡乱波动（白噪声），模型已经把有规律的信息全部挖走了，**体检合格**。

#### **第六步：发布预言（预测）**
*   **操作**：调用 `forecast(3)` 函数。
*   **结果**：模型给出了未来三个月的预测值，并在图上画出了带阴影的“置信区间”（表示预测的把握有多大）。

---

### 3. Python 实现全流程笔记

在比赛中，建议直接使用 `pmdarima` 这个库，因为它把上面复杂的“体检-定阶-建模”全流程自动化了。

```python
import pandas as pd
import matplotlib.pyplot as plt
from pmdarima import auto_arima
from statsmodels.tsa.stattools import adfuller

# 1. 加载数据 (假设 y 是用电量序列)
y = pd.Series([120, 130, 145, 160, 155, 170, 185, 200, 190, 180, 170, 165,
               180, 195, 210, 230, 225, 240, 255, 270, 260, 250, 240, 235])

# 2. 诊断：平稳性检验 (ADF检验)
result = adfuller(y)
print(f'初始数据P值: {result[1]}') # 如果 > 0.05，则不平稳

# 3. 建模与定阶：auto_arima 会自动处理差分(d)和参数(p,q)
# 它内部会对比 AIC/BIC，选出一个最省心、最精准的模型
model = auto_arima(y, 
                   start_p=0, start_q=0, 
                   max_p=3, max_q=3, 
                   d=None,           # 让它自动猜需要几次差分
                   seasonal=True,    # 如果有周期性就设为True
                   m=12,             # 12个月为一个周期
                   trace=True,       # 打印出对比过程
                   error_action='ignore', 
                   suppress_warnings=True)

print(model.summary()) # 打印出模型的所有参数

# 4. 预测未来 3 个步长
n_periods = 3
forecast, conf_int = model.predict(n_periods=n_periods, return_conf_int=True)

# 5. 可视化
plt.plot(y, label='Historical')
plt.plot(range(len(y), len(y)+n_periods), forecast, color='red', label='Forecast')
plt.fill_between(range(len(y), len(y)+n_periods), conf_int[:, 0], conf_int[:, 1], color='pink', alpha=0.3)
plt.legend()
plt.show()
```

### 总结笔记：
1.  **什么时候用？** 当你手里只有一列“数值”和一列“时间”，且需要预测后面是什么数时。
2.  **核心三步走**：
    *   **平稳化**（如果不平稳就差分）。
    *   **选参数**（看 AIC 谁小选谁）。
    *   **验效果**（看残差是不是乱码）。
3.  **比赛必杀技**：如果你的数据有非常明显的季节性（如月度销售），一定要提 **SARIMA**（季节性 ARIMA），它比普通 ARIMA 多了一个处理周期性的模块。
### 比赛论文写作建议：
1.  **第一步**：画原始序列图，说它不平稳，展示 ADF 检验结果。
2.  **第二步**：展示差分后的图，再说它平稳了，展示差分后的 ADF 结果。
3.  **第三步**：列出 AIC/BIC 的热力图或对比表，说明你为什么选了这个 $p, q$。
4.  **第四步**：展示残差的 ACF/PACF 图和 Q 检验结果，证明模型没问题。
5.  **第五步**：画出预测曲线（带阴影的可信区间），显得非常专业。