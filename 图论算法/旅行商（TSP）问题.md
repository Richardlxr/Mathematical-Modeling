## 一、 问题引入

**旅行商问题 (Traveling Salesperson Problem, TSP)** 是数学建模和组合优化中的经典问题。

### 1.1 问题定义
一名推销员要从某城市出发，经过指定的若干个城市且**每个城市恰好访问一次**，最后回到**出发城市**。如何安排路线，使得**总行程最短**？

### 1.2 核心特点
*   **Hamilton 圈**：TSP 的本质是在图中寻找一个权重最小的哈密顿圈。
*   **计算复杂度**：随着城市数量 $n$ 的增加，可能的路径数量按 $(n-1)!$ 增长。这是一个典型的 **NP-hard** 问题，城市较多时无法通过穷举法解决。

---

## 二、 0-1 整数规划建模

为了精确描述 TSP，我们可以将其转化为整数规划问题。

### 2.1 决策变量
设 $x_{ij}$ 为决策变量：
$x_{ij}=\begin{cases}1, & \text{走城市 } i \text{ 到城市 } j \text{ 的路径} \\ 0, & \text{不走该路径}\end{cases}$

### 2.2 目标函数
最小化总距离：
$min\sum_{i \neq j}d_{ij}x_{ij}$
其中 $d_{ij}$ 是城市 $i$ 与城市 $j$ 之间的距离。

### 2.3 约束条件
1.  **出度约束**：从每个城市出发只有一条边。
    $\sum_{j=1}^{n}x_{ij}=1, i=1, 2, \dots, n$
2.  **入度约束**：到达每个城市只有一条边。
    $\sum_{i=1}^{n}x_{ij}=1, j=1, 2, \dots, n$
3.  **消除子圈约束 (Subtour Elimination)**：这是最关键也最复杂的约束。它保证所有选中的边必须构成一个连通的大圈，而不是几个独立的小圈。
    $\sum_{i,j \in s}x_{ij} \le |s|-1, 2 \le |s| \le n-1, s \subset \{1, 2, \dots, n\}$

---

## 三、 改良圈算法 (Heuristic Method)

改良圈算法（Modified Circle Algorithm），在国际上常被称为 **2-opt 算法**。它是解决旅行商问题（TSP）最常用、最直观的**启发式算法**之一。

简单来说，它的逻辑就是：**先乱走一圈，然后看看哪两条路“交叉”了或者绕远了，就把它们切断重连，直到怎么连都缩短不了距离为止。**

---
### 1. 前提条件

在运行改良圈算法之前，必须具备以下基础：
1.  **一个初始圈**：你必须先有一个合法的“哈密顿圈”（即经过所有城市并回到起点的路径）。这个初始圈可以是随机生成的，也可以是用贪心法（每次走最近的城市）生成的。
2.  **距离矩阵**：你需要知道任意两个城市 $i$ 和 $j$ 之间的距离 $d_{ij}$。
3.  **完全图**：通常假设任意两个城市之间都是连通的。

---
### 2. 核心操作：2-opt 交换逻辑

改良圈算法的核心在于：**尝试切断两条边，换一种接法。**

假设当前的路径顺序是：
$$\dots \to A \to B \to \dots \to C \to D \to \dots$$
这里有两条边：边 $(A, B)$ 和 边 $(C, D)$。

**操作步骤：**
1.  **切断**：把边 $(A, B)$ 和 $(C, D)$ 删掉。
2.  **重连**：把 $A$ 连向 $C$，把 $B$连向 $D$。
3.  **翻转**：为了保持路径依然是一个闭合的圈，**原本 $B$ 到 $C$ 之间的所有城市顺序必须全部反转**。

**判断标准：**
如果新边的距离之和 < 原边的距离之和，即：
$$d_{AC} + d_{BD} < d_{AB} + d_{CD}$$
那么我们就采纳这个改进，更新路径。

---

### 3. 图解演示（可视化逻辑）

想象你在地图上画了一个圈，发现有两条线交叉了：

| 状态 | 路径序列 | 图形描述 |
| :--- | :--- | :--- |
| **修改前** | $1 \to 2 \to 3 \to 4 \to 1$ | 边 $(1,2)$ 和 $(3,4)$ 可能很长，或者有交叉 |
| **尝试重连** | 切断 $(1,2)$ 和 $(3,4)$，尝试连 $(1,3)$ 和 $(2,4)$ | - |
| **修改后** | $1 \to 3 \to 2 \to 4 \to 1$ | 路径变为了 $1-3-2-4-1$（注意2和3的顺序反了） |

---

### 4. 算法具体操作流程

1.  **生成初始圈** $C$。
2.  **枚举所有可能的配对**：
    *   在圈中选择两个不相邻的节点 $i$ 和 $j$。
    *   对应的两条边分别是 $(v_i, v_{i+1})$ 和 $(v_j, v_{j+1})$。
3.  **计算改进量**：
    *   计算当前长度之和：$L_1 = d(v_i, v_{i+1}) + d(v_j, v_{j+1})$
    *   计算交换后的长度：$L_2 = d(v_i, v_j) + d(v_{i+1}, v_{j+1})$
4.  **执行交换**：
    *   如果 $L_2 < L_1$，则将路径中从 $v_{i+1}$ 到 $v_j$ 的那一段**整个反转**。
    *   例如：原路径 `1-2-(3-4-5)-6-1`，交换 `2-3` 和 `5-6` 后，中间 `3-4-5` 变成 `5-4-3`，新路径为 `1-2-5-4-3-6-1`。
5.  **重复循环**：遍历完所有可能的 $i$ 和 $j$。如果在整个遍历过程中都没有发现可以缩短距离的交换，算法停止，输出当前圈。

---

### 5. 为什么必须要“翻转”中间的序列？

这是很多初学者最不理解的地方。我们用一个序列来说明：

假设路径是：`V1 -> V2 -> [V3 -> V4 -> V5] -> V6 -> V1`
我们要断开 `V2-V3` 和 `V5-V6`。

*   **如果不翻转**：你把 `V2` 连到 `V5`，把 `V3` 连到 `V6`。
    此时路径变成：`V1 -> V2 -> V5` ... 哎？下一步去哪？如果你去 `V6`，那么 `V3` 和 `V4` 就被漏掉了。如果你回 `V4`，那方向就乱了。
*   **翻转逻辑**：
    把 `V2` 连向 `V5`，然后**逆着走**：从 `V5` 走到 `V4`，再走到 `V3`，最后从 `V3` 连向 `V6`。
    **新序列**：`V1 -> V2 -> V5 -> V4 -> V3 -> V6 -> V1`。
    这样保证了**每个城市依然只去一次**，且路径是闭合的。

---

### 6. 改良圈算法的优缺点

| 维度     | 特点                                                                                        |
| :----- | :---------------------------------------------------------------------------------------- |
| **优点** | 计算速度极快，逻辑简单，容易编程实现。                                                                       |
| **缺点** | 容易陷入**局部最优解**。也就是说，它能保证“两两交换”不再变短，但可能存在“三三交换”或全局更优的解它找不到。（**==尝试多选几个初始圈重复几次获得较为精确的结果==**） |
| **应用** | 常作为其他高级算法（如遗传算法、模拟退火）的**辅助优化步骤**。                                                         |

---

## 五、 MATLAB 实现说明

在数学建模中，求解 TSP 的 MATLAB 常用工具或函数：
*   **`ga` (遗传算法)**：非常适合处理这类组合优化问题。
*   **`linprog` / `intlinprog`**：用于求解小规模城市（如 $n < 20$）的精确整数规划。
*   **自定义函数**：手动编写改良圈算法。

> **注意**：在 `intlinprog` 中描述“消除子圈约束”需要使用动态添加约束的方法，否则约束数量会随城市数呈指数级爆炸。